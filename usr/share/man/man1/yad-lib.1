'\" t
.\" Automatically generated by Pandoc 3.3
.\"
.TH "YAD\-LIB 1.4.0" "1" "2026\-01\-02" ""
.SH SYNOPSIS
.IP
.EX
    [ENVIRONMENT] . yad\-lib.sh               \f[I]# if installed in your $PATH\f[R]
    [ENVIRONMENT] . /path/to/yad\-lib.sh      \f[I]# otherwise\f[R]
.EE
.SH DESCRIPTION
This shell library enhances yad scripting by providing functions to:
.IP \[bu] 2
Check yad version and capabilities
.IP \[bu] 2
Restart a yad dialog keeping the same size and position
.IP \[bu] 2
Start a subdialog centered in or snapped to the current dialog
.PP
The library is compatible with \f[CR]sh\f[R], \f[CR]bash\f[R],
\f[CR]dash\f[R], and BusyBox \f[CR]ash\f[R].
It requires \f[CR]xwininfo\f[R], \f[CR]awk\f[R], and the \f[CR]proc\f[R]
file system.
.PP
\c
.UR https://github.com/step-/yad-lib
Source code
.UE \c
\ is hosted on GitHub.
For support questions please open a new \c
.UR https://github.com/step-/yad-lib/issues
issue
.UE \c
\&.
\c
.UR https://github.com/step-/yad-lib/pulls
Pull requests
.UE \c
\ are welcome.
.PP
This library is developed and tested on \c
.UR http://distro.ibiblio.org/fatdog/web/
Fatdog64 Linux
.UE \c
, where the following yad package flavors are available:
.IP \[bu] 2
\f[CR]yad_gtk2\f[R] (GTK\-2 binary), \f[CR]yad_gtk2_doc\f[R]
(documentation), \f[CR]yad_gtk3\f[R] (GTK\-3 binary) built from the \c
.UR https://github.com/step-/yad/tree/maintain-gtk2
GTK2 maintenance
.UE \c
\ repository.
.IP \[bu] 2
\f[CR]yad_ultimate\f[R] (GTK\-3 binary and documentation) built from the
\c
.UR https://github.com/v1cont/yad
upstream yad
.UE \c
\ repository.
.PP
Some features between the various flavors are different, with
\f[CR]yad_gtk2\f[R] being Fatdog64\[cq]s default; refer to \c
.UR https://github.com/step-/yad/blob/maintain-gtk2/feature-comparison.md
.UE \c
\&.
.SH TABLE OF CONTENTS
.PP
.TS
tab(@);
l l.
T{
\f[I]Library Initialization\f[R]
T}@T{
Effects on script\[cq]s environment
T}
T{
\f[I]Restarting Yad\f[R]
T}@T{
Window position and restarts
T}
T{
\f[I]Yad Window Position and Size\f[R]
T}@T{
Place the main window and a popup
T}
T{
\f[I]Blocking and Polling\f[R]
T}@T{
Advanced topic
T}
T{
\f[I]Yad Version Tests\f[R]
T}@T{
Require version and features
T}
T{
\f[I]Miscellaneous Functions\f[R]
T}@T{
Theming
T}
T{
\f[I]Documentation\f[R]
T}@T{
Export Markdown and Manual
T}
.TE
.SH FUNCTIONS
.SS Library Initialization
Source the file from your script.
This sets the global variable \f[CR]YAD_LIB_VERSION\f[R].
.PP
Initialization and other library functions that need to run the yad
binary take the command binary name from the \f[CR]YAD_LIB_YAD\f[R]
environment variable, falling back to the \f[CR]YAD_BIN\f[R] environment
variable, and finally to \f[CR]yad\f[R].
Your script may preset these variables before sourcing the library file.
.PP
By default, initialization is automatic when the library file is sourced
and the \f[CR]YAD_LIB_INIT\f[R] variable is not \[lq]\-1\[rq].
Your script may preset this variable, then call the initialization
function directly.
.SS yad_lib_init
\f[B]Usage\f[R]
.IP
.EX
    [YAD_LIB_INIT=\-1 \f[B];\f[R]] yad_lib_init [$1\-yad\-version]
.EE
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$1\-yad\-version\f[R] \[en] An optional version string in
\f[CR]major\f[R].\f[CR]minor\f[R].\f[CR]revision\f[R] format setting the
exported \f[CR]YAD_LIB_YAD_VERSION\f[R] variable.
If the parameter is empty, \f[CR]yad_lib_init\f[R] will run yad, set,
and export the \f[CR]YAD_LIB_YAD_VERSION\f[R], \f[CR]YAD_VER_CAP\f[R],
and \f[CR]YAD_STOCK_BTN\f[R] variables.
.PP
\f[B]Return Value\f[R]
.PP
\f[CR]yad_lib_init\f[R] returns 0 and sets the following global
variables:
.PP
.TS
tab(@);
l l l.
T{
Name
T}@T{
Notes
T}@T{
Used by
T}
_
T{
\f[CR]YAD_LIB_SCREEN_HEIGHT\f[R]
T}@T{
e
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_LIB_SCREEN_WIDTH\f[R]
T}@T{
e
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_LIB_YAD_VERSION\f[R]
T}@T{
e
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_VER_CAP\f[R]
T}@T{
e¹
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_STOCK_BTN\f[R]
T}@T{
e¹
T}@T{
T}
.TE
.PP
e = exported
.PD 0
.P
.PD
¹ = exported if \f[CR]$1\-yad\-version\f[R] is empty; otherwise, call
\f[CR]yad_lib_require_yad\f[R] and export the variable manually if
necessary.
.PP
\f[B]Example\f[R]
.PP
In summary, either let the library perform automatic initialization:
.IP
.EX
    . yad\-lib.sh
.EE
.PP
or load the library and initialize it manually:
.IP
.EX
    YAD_LIB_INIT=\-1
    . yad\-lib.sh \[aq]0.42.81\[aq] \f[I]# exports YAD_LIB_YAD_VERSION=0.42.81\f[R]

    \f[I]# Optionally verify that $YAD_LIB_YAD_VERSION is at least 0.42.81\f[R]
    yad_lib_require_yad \[aq]0 42 81\[aq] \f[B]||\f[R] die \[dq]yad is too old\[dq]
.EE
.SS Debugging
To enable library debugging, set the \f[CR]YAD_LIB_DEBUG\f[R]
environment variable before running your application.
\f[CR]YAD_LIB_DEBUG\f[R] is a colon\-separated list of keywords.
Each keyword enables a specific debugging tool.
Option values, if required, follow the keyword separated by an equal
sign \f[CR]=\f[R].
.PP
.TS
tab(@);
l l.
T{
Keyword
T}@T{
Refer To
T}
_
T{
\f[CR]geometry_popup\f[R]
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]geometry_popup_bash_caller\f[R]
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]geometry_popup_fontsize\f[R]
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]geometry_popup_icon\f[R]
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
.TE
.SS Restarting Yad
\f[B]Dialog Size and Position Problem Statement\f[R]
.PP
With yad, it is often necessary to capture its output and reuse the
captured data in the same dialog.
In most cases, this is not directly possible but can be achieved by
terminating the dialog and immediately restarting a new, identical one.
This dialog replacement would appear nearly imperceptible to an
observer, were it not for the window manager\[cq]s tendency to place the
new dialog at a different screen position.
Additionally, if the user resized the initial dialog, the new one will
not match that size.
.PP
We need a method for the new dialog to inherit the position and size of
the previous one.
This library implements such a method by restarting the script that runs
yad.
We refer to this method with the jargon \[lq]dispatching yad\[rq], as
discussed further below.
.PP
Note that if yad\[cq]s main dialog type supports a cycle\-read option,
you should first try that \[en] it bypasses the size and position
problem entirely.
Using cycle reading often involves restructuring your code and named
pipes, but the result is well worth the effort.
.PP
\[lq]Dispatching yad\[rq] means restarting the main script in a way that
allows reopening the dialog at the same position and size the window
occupied immediately before termination.
Dispatching yad involves terminating the currently running script when
yad closes, then restarting another instance of the script, which
relaunches yad.
.PP
To recap how to terminate yad and how this impacts dialog output:
.IP "1." 3
Clicking the \f[CR]OK\f[R] button or pressing ENTER outputs dialog data,
while clicking \f[CR]Cancel\f[R] or pressing ESC suppresses output.
.IP "2." 3
Closing the dialog window from the title bar suppresses output.
.IP "3." 3
Killing yad with \f[CR]SIGUSR1\f[R] outputs data, while
\f[CR]SIGUSR2\f[R] suppresses output.
.PP
In all three cases, before yad terminates, the library exports global
variables that the restarting script uses to open the replacement dialog
in the same screen position.
Script termination is performed by the \f[CR]yad_lib_dispatch\f[R]
\[lq]dispatcher\[rq] function, while restart is handled by the
\f[CR]yad_lib_at_restart_app\f[R] \[lq]dispatch target\[rq] function.
.PP
Let\[cq]s now demonstrate some practical examples.
.SS Dispatching From a Yad Button
First, your script performs its initialization, then calls
\f[CR]yad_lib_dispatch\f[R] near the start of the main function, before
parsing script parameters.
When the script runs yad, a button invokes the dispatch target function.
.PP
\f[B]\f[BI]Caveat\f[B]\f[R]
.PD 0
.P
.PD
Start your script with a shebang line, such as \f[CR]#!/bin/sh\f[R].
Without it, \f[CR]yad_lib_dispatch\f[R] will fail in subtle ways.
.PP
Save and run the following code as an executable shell script.
Run the script.
Resize and move the window, then click a button.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-button.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]

    \f[I]# initialize\f[R]
    info_geom=\[aq]\-\-geometry=200x80+400+400\[aq]
    info_opts=\[aq]\-\-no\-focus \-\-button=_Quit \-\-timeout=3 \-\-timeout\-indicator=bottom\[aq]
    yad=${YAD_BIN:\-yad}
    . yad\-lib.sh

    yad_lib_dispatch \[dq]$\[at]\[dq]

    \f[I]# Parse script arguments.\f[R]
    \f[I]# ...\f[R]

    \f[I]### MAIN  \f[R]\f[B]###\f[R]

    where=${YAD_GEOMETRY:\-\-\-center}

    \f[I]# Wait for yad to terminate and print output data.\f[R]
    $yad $where \[rs]
      \-\-form \-\-field=Now \[dq]$(date +%T)\[dq] \[rs]
      \-\-button=\[aq]_Quit:0\[aq] \[rs]
      \-\-button=\[dq]_Restart:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq] \f[B]|\f[R]

        \f[I]# Process output data, it\[aq]s just an example.\f[R]
        awk \-v YAD=\[dq]$yad \-\-text\-info $info_geom $info_opts\[dq] \[rs]
          \[aq]{print \[dq]Before\[dq], $0 | YAD} END {close(YAD)}\[aq]
.EE
.PP
In this example, the dispatcher function is \f[CR]yad_lib_dispatch\f[R],
and \f[CR]yad_lib_at_restart_app\f[R] is the dispatch target function.
The action of the \f[CR]Restart\f[R] button terminates the current yad
piping output to \f[CR]awk\f[R] for further processing.
\f[CR]yad_lib_at_restart_app\f[R]\[cq]s options are described further
below.
Suffice it to note that an explicit \f[CR]\-\-exit\f[R] is needed to end
the calling script \[en] otherwise, multiple running yad dialogs would
arise.
.PP
The \f[I]Yad Window Position and Size\f[R] section discusses
\f[CR]$YAD_GEOMETRY\f[R] and presents an elaborate sample script for
button dispatching.
.PP
Now let\[cq]s discuss two button action variants.
.IP "1." 3
A button can restart the dialog while inhibiting dialog output:
.RS 4
.IP
.EX
    yad \[rs]
      \-\-button=\[dq]_Quit:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-no\-capture \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq]
.EE
.PP
The word \[lq]capture\[rq] in \f[CR]\-\-no\-capture\f[R] is an
unfortunate historical misnomer, because
\f[CR]yad_lib_at_restart_app\f[R] obviously cannot capture data of its
own.
The \f[CR]\-\-no\-capture\f[R] option simply inhibits yad dialog output.
.RE
.IP "2." 3
A button can start \f[I]another\f[R] yad dialog, such as a popup prompt:
.RS 4
.IP
.EX
    yad \[rs]
      \-\-button=\[dq]_Popup:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_exec_popup_yad \-\-text=\[aq]Is everything OK?\[aq]\[rs]\[dq]\[dq]
.EE
.PP
The \f[CR]Popup\f[R] button does not terminate yad.
Instead, it opens a new yad instance \[en] the \[lq]popup\[rq]
dialog\[em]over the current yad dialog, which keeps running.
Although one might mistake the popup for a child window of the
background dialog, yad cannot create child windows.
The popup is a whole new process, and the script must handle its entire
life cycle.
.RE
.SS Dispatching From the Main Script
\f[CR]yad_lib_at_restart_app\f[R] can be used directly from the main
script, instead of from a yad button.
A detailed discussion is premature now; refer to the \f[I]Blocking and
Polling\f[R] section.
Let\[cq]s first look at the full syntax of the dispatching functions and
learn how to preserve yad position and size.
.SS yad_lib_dispatch
\f[B]Usage\f[R]
.IP
.EX
    yad_lib_dispatch [$\[at]\-arguments]
    shift $?
.EE
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$\[at]\-arguments\f[R] \[en] The command\-line arguments for the
instance of your script that is about to start.
The first positional parameter must be the name of one of the dispatch
target functions presented further below.
The remaining parameters are passed to the dispatch target function.
.PP
\f[B]Return Value\f[R]
.PP
This function returns the return value of the dispatch target function.
This is most useful when the dispatch target is
\f[CR]yad_lib_at_restart_app\f[R] and \f[CR]yad_lib_dispatch\f[R] is
passed the target\[cq]s options and script arguments.
Then add \f[CR]shift $?\f[R] after \f[CR]yad_lib_dispatch\f[R] to
consume the target\[cq]s options.
.SS yad_lib_at_restart_app
\f[B]Usage\f[R]
.IP
.EX
    yad_lib_at_restart_app [options] [\[aq]\-\-\[aq] $\[at]\-script\-arguments]
.EE
.PP
When \f[CR]yad_lib_at_restart_app\f[R] is called, a new yad instance
starts, then the old yad instance terminates (outputting its data).
The termination/restart order can be swapped.
The script that spawned the terminating yad instance can handle the data
with a shell pipe or by redirecting output to a file.
Optionally, data output can be inhibited.
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$\[at]\-script\-arguments\f[R] \[en] Pass these arguments to the
restarting script (\f[CR]$0\f[R]).
The new process gets a new PID.
\f[CR]yad_lib_at_restart_app\f[R] terminates the calling yad instance.
It is an error to omit \f[CR]\-\-\f[R] in front of the passed arguments.
.PP
\f[CR]\-\-exit[=STATUS]\f[R] \[en] Exit the current process after
terminating the calling yad instance.
The process exits with (integer) STATUS (default 0).
.PP
\f[CR]\-\-get\-cmdline=PID\f[R] \[en] If
\f[CR]$\[at]\-script\-arguments\f[R] is empty, restart the script
passing the command line that started the (integer) PID process.
This option requires the \f[CR]proc\f[R] filesystem.
In most cases, pass the value of \f[CR]$$\f[R] as the PID.
Typical usage:
.IP
.EX
    yad \-\-button=\[dq]label:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-get\-cmdline=$$\[rs]\[dq]\[dq]
.EE
.IP
.EX
    \f[I]# Faster, when $0 contains no spaces.\f[R]
    yad \-\-button=\[dq]label:$0 yad_lib_at_restart_app \-\-get\-cmdline=$$\[dq]
.EE
.PP
\f[CR]\-\-no\-capture\f[R] \[en] Inhibit output of the terminating yad
dialog.
.PP
\f[CR]\-\-terminate\-then\-restart[=SLEEP]\f[R] \[em] By default, a new
script instance starts before the running yad terminates.
With \f[CR]\-\-terminate\-then\-restart\f[R], the order swaps: first
terminate yad, then restart the script.
Use this when the restarting script needs to read the terminating
yad\[cq]s output.
SLEEP is the fractional seconds to wait between terminating yad and
restarting the script (default \f[CR]0.5\f[R]).
.PP
\f[CR]\-\-yad\-pid=PID\f[R] \[en] Terminate the yad dialog whose process
ID is (integer) PID.
Use this option when \f[CR]yad_lib_at_restart_app\f[R] is not called
from a button of the terminating yad dialog.
.PP
\f[B]Return Value\f[R]
.PP
\f[CR]123\f[R] for invalid options, otherwise the number of parsed
options.
This function does not return if \f[CR]\-\-exit\f[R] is given.
.SS yad_lib_at_exec_popup_yad
\f[B]Usage\f[R]
.IP
.EX
    yad_lib_at_exec_popup_yad [$\[at]\-yad\-arguments]
.EE
.PP
When \f[CR]yad_lib_at_exec_popup_yad\f[R] is called, a new yad window
process starts.
The script is responsible for capturing its output and terminating it.
This function is mainly a stub for illustration.
Many applications will duplicate and modify it (see \f[I]Modifying the
Dispatching Functions\f[R]).
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$\[at]\-yad\-arguments\f[R] \[en] Valid yad options passed to the
popup yad instance.
.PP
\f[B]Return Value\f[R]
.PP
The yad instance\[cq]s exit status.
.SS Modifying the Dispatching Functions
The dispatching functions presented here cover many common cases.
If your case is not covered, create your own dispatching function.
Do not edit \f[CR]yad\-lib.sh\f[R] directly.
Instead, copy the desired function code to your script and modify it
there.
Source \f[CR]yad\-lib.sh\f[R] \f[I]before\f[R] the redefined function
definition.
.PP
.SS Yad Window Position and Size
The dispatching functions presented in the previous section can keep the
position and size of the restarted yad window.
They do so by means of the functions presented in this section.
.PP
Let\[cq]s consider a hypothetical wizard\-style application, which
consists of several yad dialogs chained together.
The user moves through the dialogs one at a time by pressing a button
labeled \[lq]Next\[rq]; the current dialog window closes itself and
starts a new dialog for the next wizard step.
With vanilla yad, the user will see the new window appear in a position
selected by the Window Manager, likely an unexpected position.
Moreover, if the current window was resized, the new window will not
retain the same size.
Is there a solution?
.PP
A commonly seen, often valid solution to this issue is to fix the dialog
position and size, typically by initially placing the dialog in the
center of the screen, and locking its initial dimensions.
However, this solution can be limiting on at least two accounts.
First, choosing the right width to fix is guesswork when the application
is multilingual, and future translations are not yet available.
Second, multiple applications that run at the same time end up
contending the center of the screen and covering each other.
.PP
The solution this library provides is the
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R] function, which makes it possible to
keep the dialog size and window position when a yad dialog restarts
itself or starts a yad popup subdialog, as seen in the \f[I][Restaring
Yad]\f[R] section.
.SS yad_lib_set_YAD_GEOMETRY
\f[B]Usage\f[R]
.IP
.EX
    yad_lib_set_YAD_GEOMETRY $1\-window\-xid $2\-window\-title $3\-popup\-scale $4\-popup\-position $5\-popup\-message
.EE
.PP
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R] computes the geometry of the parent
yad window or a yad window specified by the positional parameters, and
sets environment variables that can be used to easily start another yad
window with the same geometry:
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$1\-window\-xid\f[R] \[en] Select the target yad window by its
hexadecimal id.
If \f[CR]$1\f[R] is empty, yad\[cq]s exported
\f[CR]YAD_XID\f[R]environment variable value is used instead.
If \f[CR]$YAD_XID\f[R] is also empty,
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R] selects the target window by title
\f[CR]$2\f[R].
Default \f[CR]window\-xid\f[R] value: empty string.
.PP
\f[CR]$2\-window\-title\f[R] \[en] Select the target yad window by
title.
If \f[CR]$2\f[R] is empty the value of the user\-defined
\f[CR]YAD_TITLE\f[R] variable is used.
This parameter is ignored if either \f[CR]$1\f[R] or \f[CR]$YAD_XID\f[R]
are non\-empty.
Default value: empty string.
.PP
\f[CR]$3\-popup\-scale\f[R] \[en] A string of numbers separated by
colons:
.IP
.EX
ScaleWidth:ScaleHeight:MaxWidth:MaxHeight:MinWidth:MinHeight
.EE
.PP
It is used to calculate size and position of a popup dialog; see the
\f[I]Usage Notes\f[R] subsection.
\f[CR]ScaleWidth\f[R]/\f[CR]Height\f[R] is expressed as a percentage of
the framing dialog width and height.
\f[CR]Max\f[R]/\f[CR]Min\f[R] \f[CR]Width\f[R]/\f[CR]Height\f[R] is
expressed in pixels.
Use \f[CR]\-1\f[R] and an empty value to leave
\f[CR]Scale\f[R]/\f[CR]Min\f[R]/\f[CR]Max\f[R]
\f[CR]Width\f[R]/\f[CR]Height\f[R] unconstrained.
\f[CR]Min\f[R] and \f[CR]Max\f[R] values make sense only in the context
of \f[CR]Scale\f[R], therefore they are ignored if \f[CR]Scale\f[R] is
left unconstrained.
If both \f[CR]Min\f[R] and \f[CR]Max\f[R] are given \f[CR]Min\f[R]
prevails.
Default value \f[CR]90:50:\-1:\-1:\-1:\-1\f[R], which centers a 90% by
50% scaled popup over the main dialog window.
.PP
\f[CR]$4\-popup\-position\f[R] \[en] One of \f[CR]top\f[R],
\f[CR]right\f[R], \f[CR]bottom\f[R], \f[CR]left\f[R] (also abbreviated)
to snap the popup to the respective main window side, or empty (default)
to center the popup over the main window.
.PP
\f[CR]$5\-popup\-message\f[R] \[en] Debug message.
It is ignored if popup debugging is disabled.
.PP
\f[B]Return Value\f[R]
.PP
Zero on success; otherwise silently \f[CR]123\f[R] for invalid
positional parameters, and other non\-zero for other errors.
.PP
.SS Version Notes
Since yad\-lib version 1.2, slash or comma can also be used in lieu of
colons as internal separators of the \f[CR]$3\-popup\-scale\f[R]
parameter.
.PP
Since \f[CR]YAD_LIB_VERSION\f[R] 1.4.0, for GTK\-3 and up, the value of
the \f[CR]GDK_SCALE\f[R] environment variable is further applied to the
heights and widths of the \f[CR]YAD_GEOMETRY\f[R] and
\f[CR]YAD_GEOMETRY_POPUP\f[R] output variables to provide automatic
HiDPI screen support.
.SS Usage Notes
Call \f[CR]yad_lib_set_YAD_GEOMETRY\f[R] to set \f[CR]YAD_GEOMETRY\f[R],
then export it and use it in a \f[CR]yad\f[R] command\-line that starts
or restarts the main yad dialog.
.PP
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R] also sets
\f[CR]YAD_GEOMETRY_POPUP\f[R] according to \f[CR]$3\-popup\-scale\f[R].
You can optionally export \f[CR]YAD_GEOMETRY_POPUP\f[R], and use it in a
\f[CR]yad\f[R] command\-line that starts a yad popup subdialog, that is,
a yad window that is intended to stay over the main yad dialog window,
and be quickly dismissed.
.PP
Exporting the \f[CR]YAD_GEOMETRY\f[R] and \f[CR]YAD_GEOMETRY_POPUP\f[R]
variables affects the dialog geometry of all subsequent and child
dialogs.
It is often useful to add your own, non\-exported variable, e.g.,
\f[CR]YAD_DEFAULT_POS\f[R] to assist setting up the initial geometry;
see the \f[I]Example\f[R] further below.
.PP
The format of \f[CR]YAD_GEOMETRY\f[R](\f[CR]_POPUP\f[R]) varies by yad
version as follows:
.PP
For \f[CR]YAD_LIB_YAD_VERSION\f[R] < 0.40
.IP
.EX
    \-\-geometry <width>x<height>+<posx>+<posy> \-\-width=<width>  \-\-height=<height>
.EE
.PP
For \f[CR]YAD_LIB_YAD_VERSION\f[R] >= 0.40
.IP
.EX
    \-\-posx=<posx> \-\-posy=<posy> \-\-width=<width>  \-\-height=<height>
.EE
.SS Limitations
The library tries its best to fit the popup inside the screen.
To this end it can nudge the popup away from the center of the main
window, and, in extreme cases, reduce the popup size.
However, the popup may still partially lie outside the screen because
this function does not know or control the actual size of a popup.
It just makes calculations based on the values you passed as
\f[CR]Scale\f[R], \f[CR]Min\f[R] and \f[CR]Max\f[R].
If \f[CR]Scale\f[R] is left unconstrained, yad and GTK determine the
popup size.
GTK is the ultimate ruler because yad options \f[CR]\-\-width\f[R] and
\f[CR]\-\-height\f[R] \f[I]request but do not prescribe\f[R] the size of
the window.
So, if the \f[CR]Scale\f[R], \f[CR]Min\f[R] and \f[CR]Max\f[R] values
are too small to fit the contents, GTK could display a larger window
that lies outside the screen edges.
.PP
Long text labels can pose a similar problem.
Yad displays a wider and taller window that defies relative vertical
placement over the main window.
The popup is often offset towards the bottom half of the main window.
.SS Debugging keywords
\f[CR]geometry_popup\f[R]
.PD 0
.P
.PD
Display an information window sized and positioned according to
\f[CR]$YAD_GEOMETRY_POPUP\f[R] (size might be larger if contents do not
fit) If your application calls \f[CR]yad_lib_set_gtk2_STYLEFILE\f[R] the
styles will be applied to this window.
If \f[CR]$5\-popup\-message\f[R] is set it will be shown.
.PP
\f[CR]geometry_popup_bash_caller=N\f[R]
.PD 0
.P
.PD
Include N levels of bash call\-stack frame information (default none).
Non\-negative integer N is passed to the bash \f[CR]caller\f[R]
built\-in command.
.PP
\f[CR]geometry_popup_fontsize=<Pango Markup font size>\f[R]
.PD 0
.P
.PD
Pango Markup font size value (default \[lq]x\-small\[rq]).
Make it smaller (\[lq]xx\-small\[rq]) or larger (see the Pango Markup
documentation).
.PP
\f[CR]geometry_popup_icon=<icon>\f[R]
.PD 0
.P
.PD
Set yad \f[CR]\-\-window\-icon\f[R] option (fall back to
\f[CR]YAD_OPTIONS\f[R] or yad\[cq]s icon).
.PP
\f[B]Example\f[R]
.IP
.EX
    YAD_LIB_DEBUG=\[dq]geometry_popup:geometry_popup_bash_caller=2:geometry_popup_fontsize=xx\-small:geometry_popup_icon=gtk\-dialog\-info\[dq] your_app
.EE
.PP
\f[B]Example\f[R]
.PP
The following example uses dispatching functions, which call
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R].
.PP
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-geometry.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]

    \f[I]# Initialize: Optional: set the initial position/size of the first yad window.\f[R]
    YAD_DEFAULT_POS=\[dq]\-\-mouse\[dq] \f[I]# or \-\-center, \-\-width and other yad position/size arguments\f[R]
    \f[I]# Initialize: the yad window title\f[R]
    YAD_TITLE=\[dq]Main Window Title\[dq]

    info_geom=\[aq]\-\-geometry=200x80+400+400\[aq]
    info_opts=\[aq]\-\-no\-focus \-\-button=_Quit \-\-timeout=3 \-\-timeout\-indicator=bottom\[aq]

    yad=${YAD_BIN:\-yad}
    . yad\-lib.sh
    yad_lib_dispatch \[dq]$\[at]\[dq]

    \f[I]### Main \f[R]\f[B]###\f[R]

    \f[I]# Wait for yad to terminate and print output data.\f[R]
    $yad ${YAD_GEOMETRY:\-$YAD_DEFAULT_POS} \[rs]
      \-\-title=\[dq]$YAD_TITLE\[dq] \[rs]
        \-\-form \-\-field=\[dq]Script pid\[dq] $$ \[rs]
        \-\-text=\[dq]$(date +%T) Resize and move the window, then click a button...\[dq] \[rs]
        \-\-button=\[dq]_Capture and Restart:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq] \[rs]
        \-\-button=\[dq]_No Capture:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-no\-capture \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq] \[rs]
        \-\-button=\[dq]_Popup:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_exec_popup_yad \-\-window\-icon=gtk\-dialog\-info \-\-title=Popup \-\-text=\[aq]Parent ID $$\[aq]\[rs]\[dq]\[dq] \[rs]
        \-\-button=\[aq]_Quit:0\[aq] \f[B]|\f[R]

        \f[I]# Popup example\f[R]
        awk \-v YAD=\[dq]$yad \-\-text\-info $info_geom $info_opts \-\-text \[rs]\[dq]PID $$\[aq]s output...\[rs]\[dq]\[dq] \[rs]
          \[aq]{print | YAD} END {close(YAD)}\[aq]
.EE
.SS Blocking and Polling
.SS Blocking
Function \f[CR]yad_lib_at_restart_app\f[R] also works outside the
context of yad buttons, provided it knows the running yad PID.
This facilitates implementing \f[I]blocking\f[R] scenarios, where the
main loop blocks waiting for yad to \f[I]output a message\f[R], then
takes action based on the message content.
.PP
Consider the following example, which outputs to the terminal window.
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-messaging.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]

    yad=${YAD_BIN:\-yad}
    . yad\-lib.sh

    YAD_TITLE=$$
    ! [ \-e /tmp/messages ] \f[B]&&\f[R] mkfifo /tmp/messages

    $yad $YAD_GEOMETRY \-\-title=\[dq]$YAD_TITLE\[dq] \[rs]
      \-\-text=\[dq]Resize/move the window; click a button; read stdout...\[dq] \[rs]
      \-\-form \-\-field=Pid $$ \[rs]
      \-\-button=\[dq]_Message:echo hello from $$\[dq] \[rs]
      \-\-button=\[dq]_Restart:echo restart\[dq] \[rs]
      \-\-button=_Quit:0 \[rs]
      > /tmp/messages \f[B]&\f[R]

    \f[I]# Use PID if yad_lib_at_restart_app isn\[aq]t within a \-\-button.\f[R]
      yad_pid=$!

    \f[B]while\f[R] read message\f[B];\f[R] \f[B]do\f[R]
      \f[B]case\f[R] $message \f[B]in\f[R]
        restart \f[B])\f[R] yad_lib_at_restart_app \-\-exit \-\-yad\-pid=$yad_pid \f[B];;\f[R]
        * \f[B])\f[R] echo \[dq]Message from yad: $message\[dq] \f[B];;\f[R]
      \f[B]esac\f[R]
    \f[B]done\f[R] < /tmp/messages

    rm \-f /tmp/messages
.EE
.PP
Your script can add more buttons carrying different messages and process
them in the \f[CR]case\f[R] statement to trigger complex actions.
A single button click could even output multiple messages.
.SS Polling
Not all scripts can afford blocking to wait for yad if they must pull
online data or attend other chores while the user interacts with the
GUI.
In these cases, you can still use \f[CR]yad_lib_at_restart_app\f[R] but
\f[I]poll\f[R] while running in the main loop.
.PP
Consider the following example, which outputs to the terminal window.
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-polling.sh
>download the file
.UE \c
\&.
.IP
.EX
  \f[I]#!/bin/sh\f[R]

  yad=${YAD_BIN:\-yad}
  . yad\-lib.sh
  POLLING=3

  yad_lib_dispatch \[dq]$\[at]\[dq]

  \f[I]# Parse script arguments.\f[R]

  \f[I]### MAIN \f[R]\f[B]###\f[R]

  YAD_TITLE=$$
  $yad ${YAD_GEOMETRY:\-\-\-width=400} \-\-title=\[dq]$YAD_TITLE\[dq] \[rs]
    \-\-text=\[dq]Resize/move the window; read stdout; finally click Quit...\[dq] \[rs]
    \-\-button=_Quit:0 \[rs]
    \-\-form \-\-field=Date \[dq]$(date +\[dq]Yad $$ says it\[aq]s %T\[dq])\[dq] > /tmp/output \f[B]&\f[R]

  \f[I]# Use PID with yad_lib_at_restart_app in a polling scenario.\f[R]
  yad_pid=$!

  \f[I]# $POLLING\-second polling interval.\f[R]
  \f[B]while\f[R] sleep $POLLING\f[B];\f[R] \f[B]do\f[R]
    \f[B]if\f[R] kill \-0 $yad_pid\f[B];\f[R] \f[B]then\f[R]
      yad_lib_at_restart_app \-\-yad\-pid=$yad_pid
      echo \[dq]YAD $$ restarted with output: $(cat /tmp/output)\[dq]
      exit
    \f[B]else\f[R]
      echo \[dq]Yad $$ exited with output: $(cat /tmp/output)\[dq]
      \f[B]break\f[R]
    \f[B]fi\f[R]
  \f[B]done\f[R]

  rm \-f /tmp/output
.EE
.PP
The script basically sleeps all the time waking up every
\f[CR]$POLLING\f[R] seconds to check if yad is still running.
If it is, the script restarts yad and displays its output.
Note the \f[CR]if\f[R] block requires an explicit \f[CR]exit\f[R]
command, similar to the \f[CR]\-\-exit\f[R] option for button
dispatching.
.SS Yad Version Tests
.SS yad_lib_require_yad
\f[B]Usage\f[R]
.IP
.EX
    yad_lib_require_yad $1\-x $2\-y $3\-z
.EE
.PP
Set the \f[CR]YAD_VER_CAP\f[R] global variable to the concatenation of:
.IP \[bu] 2
\f[CR]x y z\f[R] \[en] The version major, minor, and revision numbers of
the yad binary.
.IP \[bu] 2
\f[CR]:gtk\f[R](\f[CR]2\f[R]|\f[CR]3\f[R]) \[en] The GTK toolkit version
of the running file.
.IP \[bu] 2
(\f[CR]:\f[R]\f[I]capability\f[R])* \[en] Other version\-dependent
capabilities of the yad binary: \f[CR]text\-lang\f[R],
\f[CR]selectable\-labels\f[R].
.PP
If the major version is \f[CR]0\f[R], set the \f[CR]YAD_STOCK_BTN\f[R]
global variable to \[lq]gtk\[rq], otherwise to \[lq]yad\[rq].
This string can be used to set yad stock buttons portably; for example:
\f[CR]yad \-\-yad\-button=\[dq]$YAD_STOCK_BTN\-ok\[dq]\f[R].
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$1\-x\f[R] required major
.PD 0
.P
.PD
\f[CR]$2\-y\f[R] required minor
.PD 0
.P
.PD
\f[CR]$3\-z\f[R] required revision
.PP
\f[B]Return Value\f[R]
.PP
Zero if the yad binary version is at least x.y.z; otherwise non\-zero.
.SS Miscellaneous Functions
\f[B]Theming\f[R]
.SS yad_lib_set_gtk2_STYLEFILE
\f[B]Usage\f[R]
.IP
.EX
    [SN=<script name>] yad_lib_set_gtk2_STYLEFILE [options] $1\-style\-content\-keyword
.EE
.PP
Set the \f[CR]STYLEFILE\f[R] global variable to the absolute path of a
temporary, prefilled GTK\-2 style file.
.PP
The file name concatenates \[lq].\[rq], the user name, and the calling
script name taken from the \f[CR]SN\f[R] environment variable, falling
back to \f[CR]$0\f[R].
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$1\-style\-content\-keyword\f[R] \- Predefined style.
Specify one of:
.IP \[bu] 2
\f[CR]compact\f[R] \[en] Zero\-padding, minimalistic baseline style for
compact dialogs, best used in conjunction with the
\f[CR]\-\-pid\-name\f[R] option.
.PP
\f[B]Options\f[R]
.PP
\f[CR]\-\-pid\-name\f[R] \[en] Append the calling PID to the temporary
file name, creating a new file.
With this option, a unique file is created; otherwise, the file name is
fixed and other function calls will overwrite the file.
Typically, you would use this option to create the baseline style, edit
it (with \f[CR]sed\f[R] or other editor) adding your own styles, then
pass \f[CR]\-\-gtkrc=$STYLEFILE\f[R] to yad.
.PP
\f[B]Return Value\f[R]
.PP
Zero on success; otherwise silently \f[CR]123\f[R] for unknown options;
other non\-zero values for other errors.
.PP
\f[B]Notes\f[R]
.PP
The caller is responsible for removing the temporary
\f[CR]$STYLEFILE\f[R] file on exit.
.PP
\f[B]Example\f[R]
.PP
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-stylefile.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]

    yad=${YAD_BIN:\-yad}
    . yad\-lib.sh

    trap \[aq]rm \-f $STYLEFILE\[aq] INT 0 \f[I]# remove style file on Ctrl+C and exit\f[R]

    \f[B]if\f[R] [ \[dq]${YAD_VER_CAP#*:gtk2:}\[dq] = \[dq]$YAD_VER_CAP\[dq] ]\f[B];\f[R] \f[B]then\f[R]
      $yad \-\-center \-\-text \[dq]
    yad_lib_set_gtk2_STYLEFILE() affects GTK\-2 but not GTK\-3 dialogs.

    The upcoming two yad dialogs will look the same.

    Try using a GTK\-2 yad binary to see a difference.
      \[dq] \-\-button=gtk\-ok:0 \-\-timeout=5 \-\-timeout\-indicator=bottom
    \f[B]fi\f[R]

    options=\[dq]
    \-\-button=!gtk\-ok:0 \-\-button=!gtk\-cancel:1
    \-\-list \-\-column=Lines \-\-height=700 \-\-width=400
    \[dq]

    \f[B]if\f[R] ! yad_lib_set_gtk2_STYLEFILE \[dq]compact\[dq]\f[B];\f[R] \f[B]then\f[R]
      $yad \-\-text=\[dq]Error\[dq] >&2
    \f[B]else\f[R]
      $yad \-\-on\-top \-\-title=\[dq]With style file\[dq] \-\-text=\[dq]With style file\[dq] \[rs]
        \-\-gtkrc=\[dq]$STYLEFILE\[dq] \-\-posx=300 $options < \[dq]$STYLEFILE\[dq] \f[B]&\f[R]
      $yad \-\-on\-top \-\-title=\[dq]Without style file\[dq] \-\-text=\[dq]Without\[dq] \[rs]
        \-\-posx=700 $options < \[dq]$STYLEFILE\[dq] \f[B]&\f[R]
      wait
    \f[B]fi\f[R]
.EE
.SS Documentation
Library documentation is embedded in the source file.
.SS yad_lib_doc
.IP
.EX
yad_lib_doc [\-\-strip] [$1\-full\-path\-of\-yad\-lib\-file]
.EE
.PP
Output the embedded markdown documentation.
.PP
\f[B]Options\f[R]
.PP
\f[CR]\-\-strip\f[R] \[en] Output the non\-documentation lines, that is,
\[lq]Just give me the source code\[rq].
.PP
\f[B]Parameters\f[R]
.PP
\f[CR]$1\-full\-path\-of\-yad\-lib\-file\f[R] \[en] Specify the full
path of the file containing the embedded documentation.
This parameter is required if the library is installed in a
non\-standard location not included in your \f[CR]PATH\f[R] variable.
.PP
\f[B]Return Value\f[R]
.PP
Zero on success; otherwise non\-zero.
.PP
\f[B]Examples\f[R]
.PP
The following command extracts and displays Markdown text with the \c
.UR https://github.com/step-/mdview
mdview
.UE \c
\ viewer installed in Fatdog64 Linux.
.IP
.EX
    \f[B](\f[R] . yad\-lib.sh \f[B]&&\f[R] yad_lib_doc > /tmp/yad\-lib.md \f[B]&&\f[R] mdview /tmp/yad\-lib.md \f[B])\f[R] \f[B]&\f[R]
.EE
.PP
If pandoc is installed, you can convert the Markdown document to a man
page as follows:
.IP
.EX
    pandoc \-s \-fmarkdown \-tman /tmp/yad\-lib.md > /tmp/yad\-lib.1
.EE
.PP
To strip off markdown text obtaining a smaller library file:
.IP
.EX
    \f[B](\f[R]. yad\-lib.sh \f[B]&&\f[R] yad_lib_doc \-\-strip > /tmp/yad\-lib.sh\f[B])\f[R]
.EE
.SH AUTHORS
\c
.UR https://github.com/step-/yad-lib
.UE \c.
