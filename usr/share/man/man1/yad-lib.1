'\" t
.\" Automatically generated by Pandoc 3.3
.\"
.TH "YAD\-LIB 1.4.0" "1" "2025\-12\-31" ""
.SH DESCRIPTION
This shell library simplifies and enhances yad dialog management by
providing functions to:
.IP \[bu] 2
Check yad version and capabilities
.IP \[bu] 2
Restart a yad dialog keeping the same size and position
.IP \[bu] 2
Start a subdialog centered in or at the four edges of the current dialog
.IP \[bu] 2
Support HiDPI screens (GTK\-3 and up)
.PP
Section \f[I]Library Initialization\f[R] documents library
initialization options.
.PP
Section \f[I]Dispatching Yad\f[R] describes functions allowing control
of yad\[cq]s initial dialog position and size.
.PP
Section \f[I]Keeping Yad Window Position and Size\f[R], describes
functions that calculate size and position of the main dialog and of an
optional popup dialog.
.PP
The remaining sections describe functions for advanced yad usage.
.PP
This library is included in \c
.UR http://distro.ibiblio.org/fatdog/web/
Fatdog64 Linux
.UE \c
\&.
Fatdog64 provides the following yad packages: * \f[CR]yad_gtk2\f[R]
(GTK\-2 binary), \f[CR]yad_gtk2_doc\f[R] (documentation),
\f[CR]yad_gtk3\f[R] (GTK\-3 binary) * \f[CR]yad_ultimate\f[R] (GTK\-3
binary and documentation)
.PP
The first three packages derive from the \c
.UR https://github.com/step-/yad/tree/maintain-gtk2
GTK2 maintenance
.UE \c
\ repository.
\f[CR]Yad_gtk2\f[R] is the default binary in Fatdog64 Linux.
.PP
The \[lq]ultimate\[rq] package derives from the \c
.UR https://github.com/v1cont/yad
upstream yad
.UE \c
\ repository.
.PP
Note the two repositories differ on some features.
Refer to \c
.UR https://github.com/step-/yad/blob/maintain-gtk2/feature-comparison.md
.UE \c
\&.
.SH SYNOPSIS
.IP
.EX
    [ENVIRONMENT] . yad\-lib.sh               \f[I]# if installed in your $PATH\f[R]
    [ENVIRONMENT] . /path/to/yad\-lib.sh      \f[I]# otherwise\f[R]
.EE
.SS Compatibility and Requirements
The library is compatible with \f[CR]sh\f[R], \f[CR]bash\f[R],
\f[CR]dash\f[R], and busybox \f[CR]ash\f[R].
It is tested with \f[CR]yad_gtk2\f[R] and \f[CR]yad_gtk3\f[R].
It requires \f[CR]xwininfo\f[R], \f[CR]awk\f[R], and the \f[CR]proc\f[R]
file system.
.SH DOCUMENTATION
Yad\-lib source code and documentation are hosted on \c
.UR https://github.com/step-/yad-lib
github
.UE \c
\&.
For support questions please open a new \c
.UR https://github.com/step-/yad-lib/issues
issue
.UE \c
\&.
\c
.UR https://github.com/step-/yad-lib/pulls
Pull requests
.UE \c
\ are welcome.
.PP
The library source file embeds its own documentation formatted as
Markdown.
The following command extracts the markdown text and displays it with
the \c
.UR https://github.com/step-/mdview
mdview
.UE \c
\ viewer installed in Fatdog64 Linux.
.IP
.EX
\f[B](\f[R] . yad\-lib.sh \f[B]&&\f[R] yad_lib_doc > /tmp/yad\-lib.md \f[B]&&\f[R] mdview /tmp/yad\-lib.md \f[B])\f[R] \f[B]&\f[R]
.EE
.PP
If pandoc is installed, you can convert the Markdown document to a man
page as follows:
.IP
.EX
pandoc \-s \-fmarkdown \-tman /tmp/yad\-lib.md > /tmp/yad\-lib.1
.EE
.PP
To strip off markdown text obtaining a smaller library file:
.IP
.EX
\f[B](\f[R]. yad\-lib.sh \f[B]&&\f[R] yad_lib_doc \-\-strip > /tmp/yad\-lib.sh\f[B])\f[R]
.EE
.SH FUNCTIONS
.SS Library Initialization
Source the file from your script.
This sets the global variable \f[CR]YAD_LIB_VERSION\f[R].
.PP
When initialization and other library functions need to run the yad
binary, they take the command name from the \f[CR]YAD_LIB_YAD\f[R]
environment variable if set, otherwise from the \f[CR]YAD_BIN\f[R]
environment variable if set, falling back to \f[CR]yad\f[R].
Your script may preset these variables before sourcing the library file.
.PP
By default initialization is automatic when the library file is sourced
and the \f[CR]YAD_LIB_INIT\f[R] variable is not \[lq]\-1\[rq].
Your script may preset this variable then call the initialization
function directly.
.PP
The \f[CR]$1\-yad\-version\f[R] parameter must be formatted as a version
string, e.g.\ \f[CR]major\f[R].\f[CR]minor\f[R].\f[CR]revision\f[R] or
be empty.
Its value sets the exported \f[CR]YAD_LIB_YAD_VERSION\f[R] variable.
If the parameter is empty, \f[CR]yad_lib_init\f[R] will run yad and set
and export the \f[CR]YAD_LIB_YAD_VERSION\f[R], \f[CR]YAD_VER_CAP\f[R]
and \f[CR]YAD_STOCK_BTN\f[R] variables.
.PP
\f[CR]yad_lib_init\f[R] returns 0 and sets the following global
variables:
.PP
.TS
tab(@);
l l l.
T{
Name
T}@T{
Notes
T}@T{
Used by
T}
_
T{
\f[CR]YAD_LIB_SCREEN_HEIGHT\f[R]
T}@T{
e
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_LIB_SCREEN_WIDTH\f[R]
T}@T{
e
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_LIB_YAD_VERSION\f[R]
T}@T{
e
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_VER_CAP\f[R]
T}@T{
e¹
T}@T{
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R]
T}
T{
\f[CR]YAD_STOCK_BTN\f[R]
T}@T{
e¹
T}@T{
T}
.TE
.PP
e = exported
.PD 0
.P
.PD
¹ = exported if \f[CR]$1\-yad\-version\f[R] is empty otherwise call
\f[CR]yad_lib_require_yad\f[R] and export the variable manually if
necessary.
.PP
In summary, either let the library perform automatic initialization:
.IP
.EX
\&. yad\-lib.sh
.EE
.PP
or load the library and initialize it manually:
.IP
.EX
YAD_LIB_INIT=\-1
\&. yad\-lib.sh \[aq]0.42.81\[aq] \f[I]# exports YAD_LIB_YAD_VERSION=0.42.81\f[R]

\f[I]# Optionally, verify that $YAD_LIB_VERSION is at least 0.42.81\f[R]
yad_lib_require_yad \[aq]0 42 81\[aq] \f[B]||\f[R] die \[dq]yad is too old\[dq]
.EE
.SS Debugging
You can enable library debugging tools.
Set environment variable \f[CR]YAD_LIB_DEBUG\f[R] and run your
application.
\f[CR]YAD_LIB_DEBUG\f[R] is a colon\-separated list of keywords.
Each keyword enables a specific debugging tool.
Option values, if required, can be specified after the option keyword
separate by an equal sign \f[CR]=\f[R].
.PP
The following keywords are supported:
.RS
.PP
\f[CR]geometry_popup\f[R] yad_lib_set_YAD_GEOMETRY.
.RE
.RS
.PP
\f[CR]geometry_popup_caller\f[R] yad_lib_set_YAD_GEOMETRY.
.RE
.RS
.PP
\f[CR]geometry_popup_fontsize\f[R] yad_lib_set_YAD_GEOMETRY.
.RE
.RS
.PP
\f[CR]geometry_popup_icon\f[R] yad_lib_set_YAD_GEOMETRY.
.RE
.SS Dispatching Yad
In this document the term \[lq]dispatching\[rq] means restarting the
main script in a way that sets the geometry of the next yad window as it
was set by the user by dynamically resizing and moving the previous yad
window.
Dispatching involves terminating the currently running script when yad
is closed then restarting another instance of the script, which will
restart yad.
.PP
Let\[cq]s recap how to terminate yad and what happens to the user data
yad holds:
.IP "1." 3
Clicking button \f[CR]OK\f[R] and pressing the Enter key outputs the
data.
Clicking \f[CR]Cancel\f[R] and pressing the Escape key does not output
the data.
.IP "2." 3
Closing the window from the window title bar does not output the data.
.IP "3." 3
Killing yad with \f[CR]SIGUSR1\f[R] makes it output the data while
\f[CR]SIGUSR2\f[R] does not.
Yad cannot catch other signals.
.PP
In case #3, dispatching captures the window geometry immediately before
killing the current yad, then it restarts the main script passing
environment variables that the next yad can use to set its geometry.
.PP
\f[B]Dispatching from a yad button\f[R]
.PP
First, Your script should call the main dispatcher function
\f[CR]yad_lib_dispatch\f[R] at the beginning of the main body, after
performing initialization commands, and before parsing script arguments.
Then the yad command(s) within the main body should include some
\f[CR]\-\-button\f[R] option(s) to dispatch target functions.
.PP
\f[B]\f[BI]Caveat:\f[B]\f[R] your script must start with a shebang line
to set the script interpreter, for instance, \f[CR]#!/bin/sh\f[R].
Without the shebang, \f[CR]yad_lib_dispatch\f[R] will fail in a subtle
way.
.PP
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-button.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]
    \f[I]# initialize\f[R]
    . yad\-lib.sh

    yad_lib_dispatch \[dq]$\[at]\[dq]
    shift $?

    \f[I]# parse script arguments\f[R]

    \f[I]# script main body\f[R]
    \f[I]# wait for yad to terminate\f[R]
    yad $YAD_GEOMETRY \[rs]
      \-\-form \-\-field=Date \[dq]$(date +%T)\[dq] \[rs]
      \-\-button=\[dq]_Capture Output:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq]

    \f[I]# process output data, etc.\f[R]
.EE
.PP
In the above example button, \f[CR]yad_lib_dispatch\f[R] is the
dispatcher function, and \f[CR]yad_lib_at_restart_app\f[R] is the
dispatch target function.
The action in \f[CR]Capture Output\f[R] terminates the current yad and
makes it output its contents, which other parts of the script can
process.
Options, if any, after \f[CR]yad_lib_at_restart_app\f[R] are described
further down.
Take note that an explicit \f[CR]\-\-exit\f[R] is needed to end the
calling script\[en]otherwise you may end up with multiple running yad
dialogs.
If \f[CR]$0\f[R], the path to the script, contains no spaces, a simpler
\f[CR]\-\-button\f[R] syntax can be used:
.IP
.EX
    \-\-button=\[dq]_Capture Output:$0 yad_lib_at_restart_app \-\-exit \-\-get\-cmdline=$$\[dq]
.EE
.PP
Section \f[I]Keeping yad Position and Size\f[R] discusses
\f[CR]$YAD_GEOMETRY\f[R], and features an elaborate sample script for
button dispatching.
.PP
Now let us see some kinds of actions that a yad button could take.
.PP
A button could restart the dialog without capturing its
input\f[CR][1]\f[R]:
.IP
.EX
    yad \[rs]
      \-\-button=\[dq]No Capture:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-no\-capture \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq]
.EE
.PP
\f[CR][1]\f[R]: \[lq]Capture\[rq] is an unfortunate historical misnomer
because \f[CR]yad_lib_at_restart_app\f[R] does not capture data of its
own, ever.
In reality, \f[CR]\-\-no\-capture\f[R] simply inhibits yad dialog\[cq]s
output.
.PP
A button could start \f[I]another\f[R] yad dialog conceptually similar
to a popup window, such as a simple OK/Cancel prompt:
.IP
.EX
    yad \[rs]
      \-\-button=\[dq]Popup:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_exec_popup_yad \-\-text=\[aq]Is it OK?\[aq]\[rs]\[dq]\[dq]
.EE
.PP
Button \f[CR]Popup\f[R] does not terminate yad\[en]rather, it opens a
new yad instance, the \[lq]popup\[rq] dialog, while the current
(background) yad dialog keeps running.
Although one could mistake the popup for a sub\-window of the background
dialog, yad does not provide sub\-windows.
The popup is a whole new process, and your script needs to handle its
entire life cycle.
.PP
\f[B]Dispatching from the main script\f[R]
.PP
Function \f[CR]yad_lib_at_restart_app\f[R] can be used directly from the
main script, instead of from a yad button.
Section \f[I]Polling and Messaging\f[R] will show how.
Before then let\[cq]s look at the full syntax of the dispatching
functions, and learn how to preserve yad position and size.
.SS Full Syntax of Dispatcher Function
.IP
.EX
    yad_lib_dispatch [$\[at]\-arguments]
    shift $?
.EE
.PP
\f[B]Positional parameters\f[R]
.PP
\f[I]Note:\f[R] \f[CR]$\[at]\-arguments\f[R] \f[I]is a shorthand
indicating one or more shell positional parameters.\f[R]
.PP
\f[CR]$\[at]\-arguments\f[R] \- The command\-line arguments for the
instance of your script that is about to start.
The first positional parameter must be the name of one of the following
dispatching functions.
The remaining parameters are passed to the dispatching function.
.PP
\f[B]Return value\f[R]
.PP
Return the return value of the dispatch target function.
This is most useful when the dispatch target is
\f[CR]yad_lib_at_restart_app\f[R] and \f[CR]yad_lib_dispatch\f[R] is
passed target\[cq]s options and script arguments.
Then add \f[CR]shift $?\f[R] after \f[CR]yad_lib_dispatch\f[R] to
consume the target\[cq]s options.
.SS Full Syntax of Dispatch Target Functions
.IP
.EX
    yad_lib_at_restart_app [options] [\[aq]\-\-\[aq] $\[at]\-script\-arguments]
.EE
.PP
When \f[CR]yad_lib_at_restart_app\f[R] is called, a new yad instance is
started, then the old yad instance is terminated, which outputs its
data.
The termination/restart order can be swapped.
The script that spawned the terminating yad instance can handle the data
with a shell pipe or by redirecting output to a file.
Optionally, data output can be inhibited.
.PP
\f[B]Positional parameters\f[R]
.PP
\f[CR]$\[at]\-script\-arguments\f[R] \- Pass these arguments to the
restarting script (\f[CR]$0\f[R]).
The new process will take a new process id.
\f[CR]yad_lib_at_restart_app\f[R] will terminate the calling yad
instance.
It is an error to not insert \f[CR]\-\-\f[R] in front of the passed
arguments.
.PP
\f[CR]\-\-exit[=<integer>]\f[R] \- Exit the current process after
terminating the calling yad instance.
The process exits with status \f[CR]<integer>\f[R] (default 0).
.PP
\f[CR]\-\-get\-cmdline=<integer>\f[R] \- If
\f[CR]$\[at]\-script\-arguments\f[R] is empty restart the script passing
the command\-line that started process id \f[CR]<integer>\f[R].
This option requires the \f[CR]proc\f[R] file system.
In most cases you should pass the value of \f[CR]$$\f[R] as the process
id.
Typical usage:
.IP
.EX
    yad \-\-button=\[dq]label:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] \-\-get\-cmdline=$$\[rs]\[dq]\[dq]
.EE
.IP
.EX
    \f[I]# Faster, when $0 contains no spaces.\f[R]
    yad \-\-button=\[dq]label:$0 \-\-get\-cmdline=$$\[dq]
.EE
.PP
\f[CR]\-\-no\-capture\f[R] \- Inhibit output of the terminating yad
dialog.
.PP
\f[CR]\-\-terminate\-then\-restart[=<sleep>]\f[R] \- By default a new
script instance is started before the running yad is terminated.
With \[en]terminate\-then\-restart the order of these operations is
swapped; first the running yad is terminated then a new script instance
is started.
This can be be used when the restarting script needs to read the
terminating yad dialog\[cq]s output.
\f[CR]<sleep>\f[R] is the fractional number of seconds to wait between
terminating yad and restarting the script (default \f[CR]0.5\f[R]).
.PP
\f[CR]\-\-yad\-pid=<integer>\f[R] \- Terminate the yad dialog whose
process id equals \f[CR]<integer>\f[R].
You must specify this option when \f[CR]yad_lib_at_restart_app\f[R] is
not called from a button of the terminating yad dialog.
.PP
\f[B]Return value\f[R]
.PP
\f[CR]123\f[R] for invalid options, the number of parsed options
otherwise.
This function does not return if option \f[CR]\-\-exit\f[R] is given.
.PP
   *   *   *   *   *
.IP
.EX
    yad_lib_at_exec_popup_yad [$\[at]\-yad\-arguments]
.EE
.PP
When \f[CR]yad_lib_at_exec_popup_yad\f[R] is called, a new yad window
(process) is started.
Your script is responsible for capturing its output and terminating it.
This function is mainly a stub for illustration purposes.
It is expected that many applications will modify this function with
their own version (see section \f[I]Modifying the Dispatching
Functions\f[R]).
.PP
\f[B]Positional parameters\f[R]
.PP
\f[CR]$\[at]\-yad\-arguments\f[R] are valid yad options to be passed to
the popup yad instance.
.PP
\f[B]Return value\f[R]
.PP
This function returns the yad instance exit status.
.SS Modifying the Dispatching Functions
The dispatching functions that are presented here are general enough to
cover many common cases, but you may find that your specific case
isn\[cq]t covered.
.PP
To modify a function do not edit file \f[CR]yad\-lib.sh\f[R] directly.
Instead copy the desired function code to your script file and modify it
there.
Make sure to source \f[CR]yad\-lib.sh\f[R] \f[I]before\f[R] the
redefined function definition.
.PP
.SS Keeping Yad Window Position and Size
Unlike \f[CR]gtkdialog\f[R], \f[CR]yad\f[R] has no notion of its window
position; it relies entirely on the window manager to set where the next
yad instance window should appear on the screen, which could appear in a
different position at a different size.
Then the user experiences the unexpected effect of a yad window that
\[lq]jumps around\[rq] the screen.
.PP
For instance, consider a wizard\-style application, which consists of
several yad dialogs chained together.
The user moves through the dialogs one at the time by pressing a button
labelled \[lq]Next\[rq]; the current dialog window closes itself and
starts a new dialog for the next wizard step.
With vanilla yad, the user will see the new window appear in an
unexpected position.
Moreover, if the current window was resized, the new window will not
retain the same size.
.PP
A commonly implemented solution to this issue is to fix the dialog
position and size, typically by placing it in the center of the screen
with large\-enough width and height.
This solution is problematic on at least two accounts.
First, setting the width and height becomes guess\-work for applications
that can be localized because the programmer does not know in advance
how much space will translated strings take.
Second, if several instances of the same application need to run
concurrently, their windows will cover each other in the center of the
screen.
.PP
Enter function \f[CR]yad_lib_set_YAD_GEOMETRY\f[R], which makes possible
to retain the dialog size and window position when a yad dialog restarts
itself or starts a yad popup sub\-dialog.
.PP
Note: The functions presented in section \f[I]Dispatching yad\f[R] use
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R] directly.
So if your script just calls the dispatching functions \[en]as it should
do in most cases\[en] you can skip the next few paragraphs, and try the
example script at the end of this section.
Come back here for a second reading when you can.
.IP
.EX
yad_lib_set_YAD_GEOMETRY $1\-window\-xid $2\-window\-title $3\-popup\-scale $4\-popup\-position $5\-popup\-message
.EE
.PP
Function \f[CR]yad_lib_set_YAD_GEOMETRY\f[R] computes the geometry of
the parent yad window or a yad window specified by the positional
parameters, and sets environment variables that can be used to easily
start another yad window with the same geometry:
.PP
\f[B]Positional Parameters\f[R]
.PP
\f[CR]$1\-window\-xid\f[R] \- Select the target yad window by its
hexadecimal id.
If empty, it is replaced by the value of \f[CR]$YAD_XID\f[R], which yad
automatically exports to \f[I]children\f[R] dialog windows.
If also empty, \f[CR]yad_lib_set_YAD_GEOMETRY\f[R] selects the target
window by title \f[CR]$2\f[R].
Default value: empty string.
.PP
\f[CR]$2\-window\-title\f[R] \- Select the target yad window by its
title.
If empty, it is replaced by the value of \f[CR]$YAD_TITLE\f[R], which is
a user\-defined variable, if set.
Ignored if either \f[CR]$1\f[R] or \f[CR]$YAD_XID\f[R] is non\-empty.
Default value: empty string.
.PP
\f[CR]$3\-popup\-scale\f[R] \- A string of colon\- or slash\- or
comma\-separated numbers
\f[CR]ScaleWidth:ScaleHeight:MaxWidth:MaxHeight:MinWidth:MinHeight\f[R]
used to calculate size and position of a popup dialog.
See section \f[I]Calling discipline\f[R].
ScaleWidth/Height are expressed in percentage of the framing dialog
width and height, and Max/Min Width/Height are expressed in px.
\f[CR]\-1\f[R] and an empty value mean unconstrained Scale/Min/Max
Width/Height.
Min and Max values make sense only in the context of Scale, therefore
they are ignored if the Scale is specified unconstrained.
If both Min and Max are given Min prevails.
Since yad\-lib version 1.2 the separator can be slash or comma in lieu
of colon.
Default string \f[CR]90:50:\-1:\-1:\-1:\-1\f[R], which centers a 90% by
50% scaled popup over the main dialog window.
.PP
\f[CR]$4\-popup\-position\f[R] \- One of \f[CR]top\f[R],
\f[CR]right\f[R], \f[CR]bottom\f[R], \f[CR]left\f[R] (also abbreviated)
to snap the popup to the respective main window side, or empty (default)
to center the popup over the main window.
.PP
\f[CR]$5\-popup\-message\f[R] \- Debug message \- ignored if popup
debugging is disabled.
.PP
\f[B]Limitations\f[R]
.PP
The library tries its best to fit the coming popup inside the screen.
To this end it can nudge the popup away from the center of the main
window, and, in extreme cases, reduce the popup size.
However, there is no guarantee that the popup will actually fit inside
the screen.
In particular, do realize that this function can\[cq]t know or control
the actual size of a popup.
It only makes calculations based on the values specified for Scale, Min
and Max.
If Scale is specified unconstrained, yad and GTK \[en]not this
function\[en] will determine popup size.
GTK is the ultimate ruler because yad options \f[CR]\-\-width\f[R] and
\f[CR]\-\-height\f[R] \f[I]request but do not prescribe\f[R] the size of
the window.
So, if Scale, Min and Max values are too small to fit the content in a
way that GTK finds agreable, GTK will display a larger window, which
could possibly fall outside the screen boundaries.
Similarly, when yad displays a larger (typically taller) window, its
relative vertical placement over the main window will be off\-centered
(typically offset towards the bottom half of the main window).
.PP
\f[B]Calling discipline\f[R]
.PP
Two exported variables, \f[CR]YAD_GEOMETRY\f[R] and
\f[CR]YAD_GEOMETRY_POPUP\f[R], affect the dialog geometry.
An optional, non\-exported variable, \f[CR]YAD_DEFAULT_POS\f[R] (or
another variable name of your own choosing) can assist in setting up the
initial geometry, see section \f[I]Example\f[R].
.PP
Call \f[CR]yad_lib_set_YAD_GEOMETRY\f[R] to set \f[CR]YAD_GEOMETRY\f[R],
then export it and use it in a \f[CR]yad\f[R] command\-line that starts
or re\-starts the main yad dialog.
.PP
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R] also sets
\f[CR]YAD_GEOMETRY_POPUP\f[R] according to \f[CR]$3\-popup\-scale\f[R].
You can optionally export \f[CR]YAD_GEOMETRY_POPUP\f[R], and use it in a
\f[CR]yad\f[R] command\-line that starts a yad popup sub\-dialog, that
is, a yad window that is intended to show over the main yad dialog
window, and be quickly dismissed.
.PP
The format of \f[CR]YAD_GEOMETRY\f[R](\f[CR]_POPUP\f[R]) varies by yad
version as follows:
.RS
.PP
For \f[CR]YAD_LIB_YAD_VERSION\f[R] < 0.40
.RE
.IP
.EX
\-\-geometry <width>x<height>+<posx>+<posy> \-\-width=<width>  \-\-height=<height>
.EE
.RS
.PP
For \f[CR]YAD_LIB_YAD_VERSION\f[R] >= 0.40
.RE
.IP
.EX
\-\-posx=<posx> \-\-posy=<posy> \-\-width=<width>  \-\-height=<height>
.EE
.PP
\f[B]Return value\f[R]
.PP
Zero on success otherwise silently \f[CR]123\f[R] for invalid positional
parameters, and other non\-zero for other errors.
.PP
.PP
\f[B]Debugging keywords\f[R]
.RS
.PP
\f[CR]geometry_popup\f[R]
.PD 0
.P
.PD
Display an information window sized and positioned according to
\f[CR]$YAD_GEOMETRY_POPUP\f[R], although size might be larger if
contents do not fit.
If your application calls \f[CR]yad_lib_set_gtk2_STYLEFILE\f[R] the
styles will be applied to this window.
If \f[CR]$5\-popup\-message\f[R] is set it will be shown.
.RE
.RS
.PP
\f[CR]geometry_popup_caller=<n>\f[R]
.PD 0
.P
.PD
Include  levels of bash call\-stack frame information (default none).
Non\-negative integer \f[CR]<n>\f[R] is passed to the bash
\f[CR]caller\f[R] built\-in command.
.RE
.RS
.PP
\f[CR]geometry_popup_fontsize=<Pango font size>\f[R]
.PD 0
.P
.PD
Pango font size value (default \[lq]x\-small\[rq]).
Make it smaller (\[lq]xx\-small\[rq]) or larger (see the Pango
documentation).
.RE
.RS
.PP
\f[CR]geometry_popup_icon=<icon>\f[R]
.PD 0
.P
.PD
Set yad \f[CR]\-\-window\-icon\f[R] option (fall back to
\f[CR]YAD_OPTIONS\f[R] or yad\[cq]s icon).
.RE
.IP
.EX
YAD_LIB_DEBUG=\[dq]geometry_popup:geometry_popup_caller=2:geometry_popup_fontsize=xx\-small:geometry_popup_icon=gtk\-dialog\-info\[dq] your_app
.EE
.PP
\f[B]Example\f[R]
.PP
The following example uses \f[I]dispatching\f[R] functions, which call
\f[CR]yad_lib_set_YAD_GEOMETRY\f[R].
.PP
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-geometry.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]
    \f[I]# Initialize: Optional: set the initial position/size of the first yad window.\f[R]
    YAD_DEFAULT_POS=\[dq]\-\-mouse\[dq] \f[I]# or \-\-center, \-\-width and other yad position/size arguments\f[R]
    \f[I]# Initialize: the yad window title\f[R]
    YAD_TITLE=\[dq]Main Window Title\[dq]

    \f[I]# Main\f[R]
    . yad\-lib.sh
    yad_lib_dispatch \[dq]$\[at]\[dq]

        yad ${YAD_GEOMETRY:\-$YAD_DEFAULT_POS} \[rs]
          \-\-title=\[dq]$YAD_TITLE\[dq] \[rs]
            \-\-form \-\-field=\[dq]Script pid\[dq] $$ \[rs]
            \-\-text=\[dq]$(date +%T) Try resizing and moving this window then click a button...\[dq] \[rs]
            \-\-button=\[dq]_Capture Restart:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq] \[rs]
            \-\-button=\[dq]_No Capture:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_restart_app \-\-no\-capture \-\-exit \-\-get\-cmdline=$$\[rs]\[dq]\[dq] \[rs]
            \-\-button=\[dq]_Popup:sh \-c \[rs]\[dq]exec \[aq]$0\[aq] yad_lib_at_exec_popup_yad \-\-window\-icon=gtk\-dialog\-info \-\-title=Popup \-\-text=\[aq]Parent ID $$\[aq]\[rs]\[dq]\[dq] \[rs]
            \-\-button=gtk\-quit \[rs]
        \f[B]|\f[R]
        awk \[rs]
          \-v YAD=\[dq]yad \-\-window\-icon=gtk\-save \-\-no\-focus \-\-text \[rs]\[dq]Output by pid $$...\[rs]\[dq] \-\-text\-info\[dq] \[rs]
          \[aq]{print | YAD} END {close(YAD)}\[aq]
.EE
.PP
\f[B]More examples\f[R]
.PP
\c
.UR https://github.com/step-/scripts-to-go/blob/master/README.md#dndmate
dndmate
.UE \c
\ manages a yad paned dialog and several popup subdialogs with the help
of \f[CR]yad_lib_set_YAD_GEOMETRY\f[R].
This is a full \[en] and complex \[en] example.
.SS Blocking and Polling
Dispatching with function \f[CR]yad_lib_at_restart_app\f[R] also works
outside the context of a yad button, as long as it is given the process
id of a running yad dialog.
This can be useful in a \f[I]blocking\f[R] scenario, in which the main
loop blocks waiting for \f[I]message output\f[R] from yad then takes
actions based on message content.
.PP
Consider the following example, which outputs to the terminal window.
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-messaging.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]
    . yad\-lib.sh

    YAD_TITLE=$$
    ! [ \-e /tmp/messages ] \f[B]&&\f[R] mkfifo /tmp/messages

    yad $YAD_GEOMETRY \-\-title=\[dq]$YAD_TITLE\[dq] \[rs]
      \-\-form \-\-field=Pid $$ \[rs]
      \-\-button=\[dq]_Message:echo hello from $$\[dq] \[rs]
      \-\-button=\[dq]_Restart:echo restart\[dq] \[rs]
      \-\-button=gtk\-quit:0 \[rs]
      > /tmp/messages \f[B]&\f[R]
      yad_pid=$!

    sleep 0.1

    \f[B]while\f[R] read message\f[B];\f[R] \f[B]do\f[R]
      \f[B]case\f[R] $message \f[B]in\f[R]
        restart \f[B])\f[R] yad_lib_at_restart_app \-\-exit \-\-yad\-pid=$yad_pid \f[B];;\f[R]
        * \f[B])\f[R] echo \[dq]Message from yad: $message\[dq] \f[B];;\f[R]
      \f[B]esac\f[R]
    \f[B]done\f[R] < /tmp/messages

    rm \-f /tmp/messages
.EE
.PP
You can add more buttons with different types of messages, and process
the messages in the \f[CR]case\f[R] statement.
Note that the button can execute any complex command or script, not just
\f[CR]echo\f[R].
A single button click can even output multiple messages.
.PP
   *   *   *   *   *
.PP
Some scripts can\[cq]t block the main loop waiting for output from yad.
Such is the case for scripts that need to do other things while the user
interacts with yad, like fetching more data from online sources or
attending to other yad windows.
You can still use \f[CR]yad_lib_at_restart_app\f[R] in those cases, and
\f[I]poll\f[R] in the main loop.
.PP
Consider the following example, which outputs to the terminal window.
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-dispatch-polling.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]
    \f[I]# initialize\f[R]
    . yad\-lib.sh
    seconds=3

    yad_lib_dispatch \[dq]$\[at]\[dq]
    shift $?

    \f[I]# parse script arguments\f[R]

    \f[I]# script main body\f[R]
    YAD_TITLE=$$
    yad ${YAD_GEOMETRY:\-\-\-width=400} \-\-title=\[dq]$YAD_TITLE\[dq] \[rs]
      \-\-form \-\-field=Date \[dq]$(date +\[dq]Yad $$ says it\[aq]s %T\[dq])\[dq] > /tmp/output \f[B]&\f[R]
    yad_pid=$!

    \f[I]# polling at $seconds second intervals\f[R]
    \f[B]while\f[R] sleep $seconds\f[B];\f[R] \f[B]do\f[R]

      \f[B]if\f[R] ps $yad_pid >/dev/null\f[B];\f[R] \f[B]then\f[R]
        yad_lib_at_restart_app \-\-yad\-pid=$yad_pid
        echo \[dq]YAD $$ restarted with output: $(cat /tmp/output)\[dq]
        exit
      \f[B]else\f[R]
        echo \[dq]Yad $$ exited with output: $(cat /tmp/output)\[dq]
        \f[B]break\f[R]
      \f[B]fi\f[R]

    \f[B]done\f[R]
.EE
.PP
When you press button \f[CR]OK\f[R] yad exits in the else\-block.
If you don\[cq]t press a button, after the polling period expires yad is
restarted in the if\-block.
Note that the if\-block needs an \f[CR]exit\f[R] statement akin to the
\f[CR]\-\-exit\f[R] option for the button dispatching case.
.PP
\f[B]More examples\f[R]
.PP
\c
.UR https://github.com/step-/scripts-to-go/blob/master/README.md#fatdog-wireless-antenna
fatdog\-wireless\-antenna
.UE \c
\ manages its window with a polling scheme.
.SS Requiring a Specific Yad Version
.IP
.EX
    yad_lib_require_yad $1\-x $2\-y $3\-z
.EE
.PP
Set the \f[CR]YAD_VER_CAP\f[R] global variable to the concatenation of
strings * \f[CR]x y z\f[R] \- the version major, minor, and revision
numbers of the yad binary.
* \f[CR]:gtk\f[R](\f[CR]2\f[R]|\f[CR]3\f[R]) \- the GTK+ toolkit version
of the running file * (\f[CR]:\f[R]\f[I]capability\f[R])* \- other
version\-dependent capabilities of the yad binary:
\f[CR]text\-lang\f[R], \f[CR]selectable\-labels\f[R].
.PP
If the version major is \f[CR]0\f[R], set the \f[CR]YAD_STOCK_BTN\f[R]
global variable to \[lq]gtk\[rq], otherwise to \[lq]yad\[rq].
This string can be used to set yad stock buttons portably:
e.g.\ \f[CR]yad \-\-yad\-button=\[dq]$YAD_STOCK_BTN\-ok\[dq]\f[R].
.PP
\f[B]Positional parameters\f[R]
.PP
\f[CR]$1\-x\f[R] required major
.PD 0
.P
.PD
\f[CR]$2\-y\f[R] required minor
.PD 0
.P
.PD
\f[CR]$3\-z\f[R] required revision
.PP
\f[B]Return Value\f[R]
.PP
Zero if the yad binary version is at least x.y.z, non\-zero otherwise.
.SS Theming Yad With a GTK2 Style File
.IP
.EX
    [SN=<script name>] yad_lib_set_gtk2_STYLEFILE [options] $1\-style\-content\-keyword
.EE
.PP
Set global variable \f[CR]STYLEFILE\f[R] to the absolute path of a
temporary GTK2 style file.
.PP
The file name is composed of the user name and the calling script file
name specified through environment variable \f[CR]SN\f[R], if set,
otherwise from \f[CR]$0\f[R].
See also option \f[CR]\-\-pid\-name\f[R] below.
.PP
\f[B]Positional parameters\f[R]
.PP
\f[CR]$1\-style\-content\-keyword\f[R] \- Select pre\-defined style
definitions.
One of
.IP \[bu] 2
\f[CR]\[dq]compact\[dq]\f[R] \- Zero paddings and other style parameters
to make the dialog as compact as possible.
.PP
\f[B]Options\f[R]
.PP
\f[CR]\-\-pid\-name\f[R] \- Append the calling PID to the temporary file
name, and create a new file.
Without this option, the file name is fixed \- given the calling script
\- and it does not overwrite an existing file by the same name.
This allows for editing the file outside this library.
.PP
\f[B]Return Value\f[R]
.PP
Zero on success otherwise silently \f[CR]123\f[R] for unknown options,
and other non\-zero for other errors.
.PP
\f[B]Notes\f[R]
.PP
The calling script should remove temporary file \f[CR]$STYLEFILE\f[R] on
exit.
.PP
\f[B]Example\f[R]
.PP
Save and execute the following code as an executable shell script.
\c
.UR https://github.com/step-/yad-lib/blob/master/usr/share/yad-lib/test-stylefile.sh
>download the file
.UE \c
\&.
.IP
.EX
    \f[I]#!/bin/sh\f[R]
    . yad\-lib.sh >/dev/null
    trap \[aq]rm \-f $STYLEFILE\[aq] INT 0 \f[I]# remove style file on Ctrl+C and exit\f[R]
    \f[B]if\f[R] ! yad_lib_set_gtk2_STYLEFILE \[dq]compact\[dq]\f[B];\f[R] \f[B]then\f[R]
      echo \[dq]Handle some error\[dq] >&2
    \f[B]fi\f[R] \f[B]&&\f[R]
    yad \-\-title=\[dq]With style file\[dq] \-\-gtkrc=\[dq]$STYLEFILE\[dq] \f[B]&\f[R]
    yad \-\-title=\[dq]Without style file\[dq] \f[B]&\f[R]
.EE
.SS Sundry
.IP
.EX
yad_lib_doc [\-\-strip] [$1\-full\-path\-of\-yad\-lib\-file]
.EE
.PP
Output the embedded markdown documentation.
See also section \f[I]Usage and Documentation\f[R].
.PP
\f[B]Options\f[R]
.PP
\f[CR]\-\-strip\f[R] \- Output non\-documentation lines, that is,
\[lq]Just give me the source code\[rq].
.PP
\f[B]Positional parameters\f[R]
.PP
\f[CR]$1\-full\-path\-of\-yad\-lib\-file\f[R] \- Specify the full path
of the file containing the embedded documentation.
Required if the library is installed in a non\-standard location not
included in your \f[CR]PATH\f[R] variable.
.PP
\f[B]Return value\f[R]
.PP
Zero on success, non\-zero on error.
.SH AUTHORS
\c
.UR https://github.com/step-/yad-lib
.UE \c.
